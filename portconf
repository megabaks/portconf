#!/bin/bash
# Copyright megabaks
# Distributed under the terms of the GNU General Public License v3 or later
############################################################################
################ check_openrc ##############################################
[[ -f "/etc/init.d/functions.sh" ]] && . /etc/init.d/functions.sh
############################################################################
################ colors ####################################################
green="\033[01;32m"
red="\033[01;31m"
restore="\033[00m"
contrast="\033[1m"
underline="\033[4m"
############################################################################
################ init ######################################################
PKGDB="/var/db/pkg"
BRDIR="/var/lib/portconf"
PORT_ETC="/etc/portage"
WORLD="/var/lib/portage/world"
[[ -f "/etc/portconf.conf" ]] && . /etc/portconf.conf
[[ -z "${COUNT}" ]] && COUNT="10"
############################################################################
################ ignore ####################################################
[[ -n "${IGNORE_CATEGORY}" ]] && IGNORE_CATEGORY="$(sed -e '/^$/d' -e 's/$/\/.*/g' <<< "`tr "[:space:]" $'\n' <<< "${IGNORE_CATEGORY}"`")"
[[ -n "${IGNORE_PN}" ]] && IGNORE_PN="$(sed -e '/^$/d' -e 's/^/.*\//g' <<< "`tr "[:space:]" $'\n' <<< "${IGNORE_PN}"`")"
IGNORE="${IGNORE_CATEGORY}
${IGNORE_PN}"
IGNORE="$(sed -e '/^$/d' <<< "${IGNORE}")"
[[ -z "${IGNORE}" ]] && IGNORE="Hello, LOR!!! :3"
############################################################################
################ sort_passed_uses ##########################################
sort_passed_uses(){
	for opt in ${1};do
		uses="$(echo -e ${uses} | tr "[:space:]" $'\n' | grep -v "^${opt#-}$" | grep -v "^\-${opt#-}$" | tr $'\n' " ")"
		uses+=" $(echo ${1} | tr "[:space:]" $'\n' | grep -e "^${opt#-}$" -e "^\-${opt#-}$" | tail -n1)"
		unset opt
	done
	echo ${uses}
	unset uses
}
############################################################################
################ profile ###################################################
profile() {
	local use;
	local path;
	[[ -f "${1}/make.defaults" ]] && . "${1}/make.defaults"
	use="$USE"
	if [[ -f "${1}/parent" ]]; then
		for path in `cat ${1}/parent`;do
			use="$use $(profile "${1}/$path")"
		done
	fi
	echo $use
}
	if [[ -h "/etc/make.profile" ]];then
		pre_profile="$(profile `readlink /etc/make.profile | sed -e 's|\.\.||'`)"
	else
		pre_profile="$(profile `readlink /etc/portage/make.profile | sed -e 's|\.\.||'`)"
	fi
profile_uses="$(sort_passed_uses "${pre_profile}")"
PROFILE="$(tr "[:space:]" $'\n' <<< ${profile_uses})"
############################################################################
################ all_use_all_profiles ######################################
all_use_all_profiles(){
	for target in `eselect --brief profile list`;do
		profile_uses="$(profile "/usr/portage/profiles/${target}")"
		USEs="$(sort_passed_uses "${profile_uses}")"
		echo -e "\n${green}${target}${restore}: "${USEs} | fold -s -w `tput cols`
		unset USEs
	done
}
############################################################################
################ profile_use ###############################################
profile_use(){
	PS3=`echo -e "${contrast}Choose number:${restore} "`
	select target in `eselect --brief profile list`;do
		profile_uses="$(profile "/usr/portage/profiles/${target}")"
		USEs="$(sort_passed_uses "${profile_uses}")"
		echo -e "\n${green}${target}${restore}: "${USEs} | fold -s -w `tput cols`
		unset USEs
		break
	done
}
############################################################################
################ current_profile ###########################################
current_profile(){
	if [[ -h "/etc/make.profile" ]];then
		target="$(readlink /etc/make.profile | sed 's|.*/profiles/||')"
	else
		target="$(readlink /etc/portage/make.profile | sed 's|.*/profiles/||')"
	fi
	profile_uses="$(profile "/usr/portage/profiles/${target}")"
	USEs="$(sort_passed_uses "${PROFILE}")"
	echo -e "${green}${target}${restore}: "${USEs} | fold -s -w `tput cols`
	unset USEs
}
############################################################################
################ make.conf #################################################
[[ -f "/etc/make.conf" ]] && . /etc/make.conf 2>/dev/null
[[ -f "${PORT_ETC}/make.conf" ]] && . ${PORT_ETC}/make.conf 2>/dev/null
MAKE_USES="${USE}"
unset USE
[[ -z "${PORTDIR}" ]] && PORTDIR="/usr/portage"
############################################################################
################ timestamp #################################################
timestamp(){
	ls -dgo --time-style=+%s --color=never ${*} 2>/dev/null | awk '{print $4}' | sort | tail -n1
}
############################################################################
################ repo fix ##################################################
repo_fix(){
	if [[ -n "${PORTDIR_OVERLAY}" ]];then
		for path in ${PORTDIR_OVERLAY};do
			local_categories="$(ls -1 ${path}/*/*/*.ebuild | sed -e "s|${path}/||g;s|/.*||g" | sort -u)"
			portage_categoties="$(cat ${PORTDIR}/profiles/categories)"
			if [[ -n "$(grep -v "${portage_categoties}" <<< "${local_categories}")" ]];then
				if [[ ! -f "${path}/profiles/categories" ]];then
					[[ ! -d "${path}/profiles" ]] && mkdir "${path}/profiles" && tmp_categories+=" ${path}/profiles"
					echo -e "Creating temporary 'categories': ${path}"
					echo "${local_categories}" >> "${path}/profiles/categories"
					tmp_categories+=" ${path}/profiles/categories"
				fi
			fi
		done
	fi
}
############################################################################
################ rm repo fix ###############################################
rm_repo_fix(){
	if [[ -n "${tmp_categories}" ]];then
		for tmp_category in ${tmp_categories};do
			rm -rf "${tmp_category}"
		done
	fi
}
############################################################################
################ eix check #################################################
eix_check(){
	if [[ -n "$(eix --version 2>/dev/null)" ]];then
		echo -e "${underline}Creating new temporary cache.${restore}"
		repo_fix
		eix_cache="$(mktemp)"
		chown portage:portage "${eix_cache}" 2>/dev/null
		export EIX_CACHEFILE="${eix_cache}"
		export OVERLAY_CACHE_METHOD="parse|ebuild*"
		eix-update
	else
		echo -e "${green}app-portage/eix${restore} ${red}not installed!${restore}"
		eend 1 2>/dev/null
		exit 1
	fi
	rm_repo_fix
}
############################################################################
################ eix check method ##########################################
eix_method(){
	if [[ -n "$(eix --version 2>/dev/null)" ]];then
		if [[ -z "$(eix --dump | grep '^OVERLAY_CACHE_METHOD="parse|ebuild\*"')" ]];then
			[[ -n "${yes}" ]] && eix_check
			echo -ne "\n${red}!default 'OVERLAY_CACHE_METHOD'${restore}${contrast} \
Create temporary cache?${restore} [${green}Yes${restore}/${red}No${restore}] ";
			while read x;do
				case ${x} in
					Yes | YES | yes | Y | y | "" )
						eix_check
						break;;
					No | NO | no | N | n )
						repo_fix
						eix-update
						rm_repo_fix
						break;;
					* ) echo -ne "Sorry, response '${x}' not understood. [${green}Yes${restore}/${red}No${restore}] "
						continue;;
				esac
			done
		fi
	else
		echo -e "${green}app-portage/eix${restore} ${red}not installed!${restore}"
		eend 1 2>/dev/null
		exit 1
	fi
}
############################################################################
################ backup ####################################################
backup(){
	[[ -d "${BRDIR}" ]] || mkdir "${BRDIR}"
	tarballs="$(ls -1 --color=never ${BRDIR})"
	oldest="$(head -n1 <<< "${tarballs}")"
	newest="$(tail -n1 <<< "${tarballs}")"
	count="$( wc -l <<< "${tarballs}")"
	[[ -z "${count}" ]] && count="0"
	if [[ -f "/etc/make.conf" ]];then
		etc_update="$(timestamp ${PORT_ETC}/{*,*/*,*/*/*,*/*/*/*} /etc/make.conf)"
	else
		etc_update="$(timestamp ${PORT_ETC}/{*,*/*,*/*/*,*/*/*/*})"
	fi
	portconf_update="$(timestamp ${BRDIR}/*)"
	[[ -z "${portconf_update}" ]] && portconf_update="0"
	if (( "${etc_update}" > "${portconf_update}" ));then
		if (( "${count}" >= "${COUNT}" ));then
			rm "${BRDIR}/${oldest}"
		fi
		echo -e "/etc/portage backup: ${green}creating${restore}..."
		name="${BRDIR}/portage_$(date +%g.%m.%d-%H:%M).tar.bz2"
		if [[ -f "/etc/make.conf" ]];then
			tar -jcf "${name}" -C /etc/ portage make.conf
		else
			tar -jcf "${name}" -C /etc/ portage
		fi
		eend $? 2>/dev/null
	else
		echo -e "/etc/portage backups: ${green}already up-to-date${restore}"
		eend $? 2>/dev/null
	fi
}
############################################################################
################ world_backup ##############################################
world_backup(){
	world_dir="${BRDIR}/world"
	[[ -d "${world_dir}" ]] || mkdir "${world_dir}"
	tarballs="$(ls -1 --color=never ${world_dir})"
	oldest="$(head -n1 <<< "${tarballs}")"
	newest="$(tail -n1 <<< "${tarballs}")"
	count="$( wc -l <<< "${tarballs}")"
	[[ -z "${count}" ]] && count="0"
	world_update="$(timestamp ${WORLD})"
	portconf_update="$(timestamp ${world_dir}/*)"
	[[ -z "${portconf_update}" ]] && portconf_update="0"
	if (( "${world_update}" > "${portconf_update}" ));then
		if (( "${count}" >= "${COUNT}" ));then
			rm "${world_dir}/${oldest}"
		fi
		echo -e "world backup: ${green}creating${restore}..."
		name="${world_dir}/world_$(date +%g.%m.%d-%H:%M).tar.bz2"
		tar -jcf "${name}" -C ${WORLD%world} world
		eend $? 2>/dev/null
	else
		echo -e "world backups: ${green}already up-to-date${restore}"
		eend $? 2>/dev/null
	fi
}
############################################################################
################ restore ###################################################
restore(){
	tarballs="$(ls -1 --color=never ${BRDIR})"
	tarballs="${tarballs//.tar.bz2/}"
	tarballs="${tarballs//portage_/}"
	PS3=`echo -e "${contrast}Choose number:${restore} "`
	echo -e "${contrast}Available backups${restore}:"
	select answer in ${tarballs};do
		echo -e "Rolling back ${PORT_ETC} to the state ${green}${answer}${restore}"
		rm -rf ${PORT_ETC}/*
		tar -xf "${BRDIR}/portage_${answer}.tar.bz2" -C /etc/ 2>/dev/null
		eend $? 2>/dev/null
		break
	done
}
############################################################################
################ world_restore #############################################
world_restore(){
	world_dir="${BRDIR}/world"
	tarballs="$(ls -1 --color=never ${world_dir})"
	tarballs="${tarballs//.tar.bz2/}"
	tarballs="${tarballs//world_/}"
	PS3=`echo -e "${contrast}Choose number:${restore} "`
	echo -e "${contrast}Available backups${restore}:"
	select answer in ${tarballs};do
		echo -e "Rolling back ${WORLD} to the state ${green}${answer}${restore}"
		tar -xf "${world_dir}/world_${answer}.tar.bz2" -C ${WORLD%world} 2>/dev/null
		eend $? 2>/dev/null
		break
	done
}
############################################################################
################ diff_ask ##################################################
diff_ask(){
	my_diff="$(diff -Nau0 "${1}" "${2}" | tr -d '\' 2>/dev/null)"
	if [[ -n "${my_diff}" ]];then
		while read line;do
			if ! grep -q '\-\-\-' <<< "${line}" && ! grep -q '+++' <<< "${line}" && ! grep -q '@@' <<< "${line}";then
				string="$(sed -e 's|/|\\/|g' -e 's|^+||;s|^-||' -e 's|\*|\\*|g' <<< "${line}")"
				[[ -n "${string}" ]] && plus="$(cat "${2}" | grep -n "${string}" | cut -d\: -f1 | tr $'\n' " ")" || plus="X"
				[[ -n "${string}" ]] && minus="$(cat "${1}" | grep -n "${string}" | cut -d\: -f1 | tr $'\n' " ")" || minus="X"
				[[ "${minus}" != "X" ]] && for x in ${minus};do
					[[ "$(sed -n "${x}p" ${1} 2>/dev/null)" == "$(sed -n "${x}p" ${2} 2>/dev/null)" ]] &&\
					minus="${minus//${x}/}" && minus_exist=" == line ${contrast}${x}${restore}"
				done
				minus="${minus# }"
				minus="${minus% }"
				[[ "${plus}" != "X" ]] && for z in ${plus};do
					[[ "$(sed -n "${z}p" ${1} 2>/dev/null)" == "$(sed -n "${z}p" ${2} 2>/dev/null)" ]] &&\
					plus="${plus//${z}/}"  && plus_exist=" == line ${contrast}${x}${restore}"
				done
				plus="${plus# }"
				plus="${plus% }"
				if grep -q "^-" <<< "${line}";then
					for i in ${minus};do
						! grep -q "${i}.*:.*${red//\[/\\[}.*:" <<< "${full_diff}" && full_diff+="${i}\t:${red}${line}${restore}: ${minus_exist}\n"
					done
				fi
				if grep -q "^+" <<< "${line}";then
					for i in ${plus};do
						! grep -q "${i}.*:.*${green//\[/\\[}.*:" <<< "${full_diff}" && full_diff+="${i}\t:${green}${line}${restore}: ${plus_exist}\n"
					done
				fi
			fi
			unset plus minus minus_exist plus_exist
		done <<< "${my_diff}"
		echo -e "\n${contrast}Changes for ${green}${1}${restore}:${restore}"
		echo "###############################################"
		echo -e "${full_diff%\\n}" | grep \:
		echo "###############################################"
		if [[ -z "${yes}" && -z "${pretend}" ]];then
			echo -ne "${contrast}Apply changes?${restore} [${green}Yes${restore}/${red}No${restore}] ";
			while read x;do
				case ${x} in
					Yes | YES | yes | Y | y | "" )
						if [[ "${UID}" == "0" ]];then
							mv "${2}" "${1}" 2>/dev/null
							chmod 0644 "${1}"
						else
							echo -e "you are ${red}!root${restore} ---> go away!"
							exit 1
						fi
						unset full_diff
						return 0
						break;;
					No | NO | no | N | n )
						unset full_diff
						rm "${2}" 2>/dev/null
						return 0
						break;;
					* ) echo -ne "Sorry, response '${x}' not understood. [${green}Yes${restore}/${red}No${restore}] "
						continue;;
				esac
			done
		elif [[ -n "${yes}" && -z "${pretend}" ]];then
			mv "${2}" "${1}" 2>/dev/null
			chmod 0644 "${1}"
			unset full_diff
			return 0
		elif [[ -z "${yes}" && -n "${pretend}" ]];then
			unset full_diff
			rm "${2}" 2>/dev/null
			return 0
			break
		fi
	fi
	rm "${2}" 2>/dev/null
	return 0
}
############################################################################
################ remove_ask ################################################
remove_ask(){
	if [[ -z "${yes}" && -z "${pretend}" ]];then
		echo -ne "${contrast}Remove${restore} ${green}${1}${restore}${contrast}?${restore} [${green}Yes${restore}/${red}No${restore}] "
		while read x;do
			case ${x} in
				Yes | YES | yes | Y | y | "" )
					rm -rf ${1} 2>/dev/null
					break;;
				No | NO | no | N | n )
					break;;
				* ) echo -ne "Sorry, response '${x}' not understood. [${green}Yes${restore}/${red}No${restore}] "
					continue;;
			esac
		done
		eend $? 2>/dev/null
	elif [[ -n "${yes}" && -z "${pretend}" ]];then
		echo -e "${contrast}Removing${restore} ${green}${1}${restore}"
		rm -rf ${1} 2>/dev/null
		eend $? 2>/dev/null
	elif [[ -z "${yes}" && -n "${pretend}" ]];then
		eend 0 2>/dev/null
	fi
}
############################################################################
################ sort_packages #############################################
sort_uniq_files(){
	for package in `find ${PORT_ETC}/ -type f \! -name '*~' \! -name '*.bak' | grep "/package\."`;do
		tmp_sort="$(mktemp)"
		echo -e "${underline}Sorting${restore} ${contrast}${package#${PORT_ETC}/}${restore}"

		all_atoms="$(awk '{print $1}' "${package}" | grep -v "^#"| sort -u)"
		while read atom;do
			opts="$(grep "^${atom} " "${package}" | uniq | cut -d" " -f2-)"
			echo "${atom} ${opts//$'\n'/ }" >> "${tmp_sort}"
		done <<< "${all_atoms}"

		sed -e '/^$/d' -e 's/[ \t]*$//' -i ${tmp_sort}
		sort -u "${tmp_sort}" -o "${tmp_sort}" 2>/dev/null
		diff_ask "${package}" "${tmp_sort}"
		eend $? 2>/dev/null
	done
}
############################################################################
################ file or dir... ############################################
file_or_dir(){
	founded="$(ls -d1 ${PORT_ETC}/${1} 2>/dev/null)"
	if [[ -z "${founded}" ]];then
		echo -e "${underline}${2}${restore}\n${contrast}${PORT_ETC}/${1}${restore}: No such file o directory${restore}"
		eend 1 2>/dev/null
		return 1
	fi
	for target in ${founded};do
		if [[ -f "${target}" ]];then
			file="${target}"
			if [[ -s ${file} ]];then
				echo -e "${underline}${2}${restore} ${contrast}${file#${PORT_ETC}/}${restore}"
				${3};${4};${5};${6};${7};
			else
				echo -e "${underline}Empty file${restore} ${contrast}${file}${restore}"
				remove_ask "${file}"
				eend $? 2>/dev/null
			fi
		elif [[ -d "${target}" ]];then
			for f in `find ${target} -type f \! -name '*~' \! -name '*.bak'`;do
				file="${f}"
				if [[ -s ${file} ]];then
					echo -e "${underline}${2}${restore} ${contrast}${file#${PORT_ETC}/}${restore}"
					${3};${4};${5};${6};${7};
				else
					echo -e "${underline}Empty file${restore} ${contrast}${file}${restore}"
					remove_ask "${file}"
					eend $? 2>/dev/null
					continue
				fi
			done
		fi
	done
}
############################################################################
################ rm_comments ###############################################
rm_comments(){
	no_newline(){
		tmp_file="$(mktemp)"
		cp "${file}" "${tmp_file}"
		sed -e "s|^#.*||g" -e '/^$/d' -i ${tmp_file}
		diff_ask "${file}" "${tmp_file}"
		eend $? 2>/dev/null
	}
	file_or_dir "package.*" "Checking comments:" "no_newline" || return 1
}
############################################################################
################ rm_all_comments ###########################################
rm_all_comments(){
	no_newline_inline(){
		tmp_file="$(mktemp)"
		cp "${file}" "${tmp_file}"
		sed -e "s|#.*||g" -e 's/[ \t]*$//' -e '/^$/d' -i ${tmp_file}
		diff_ask "${file}" "${tmp_file}"
		eend $? 2>/dev/null
	}
	file_or_dir "package.*" "Checking comments:" "no_newline_inline"  || return 1
}
############################################################################
################ sort_uses #################################################
sort_uses(){
	tmp_file="$(mktemp)"
	striped="$(mktemp)"
	PACKAGES="$(awk '{print $1}' ${file} | grep -v '^#.*' | uniq)"
	for atom in ${PACKAGES};do
		comment="$(grep "${atom}[[:space:]].*#" "${file}" | cut -d\# -f2-)"
		for option in \
		"$(grep "^${atom}[[:space:]]" ${file} | sed -e "s|${atom} ||" -e "s|#.*${comment}||" | tr "[:space:]" $'\n' | uniq | tr $'\n' " ")";do
			atom_opts+="${option}"
		done
		uses="$(sort_passed_uses "${atom_opts}")"
		uses="$(sed -e "s|^- | |g" -e "s| -- ||g" -e "s| - | |g" <<< ${uses})"
		if [[ -n "${comment}" ]];then
			echo "${atom} ${uses} #${comment}" >> "${tmp_file}"
		else
			echo "${atom} ${uses}" >> "${tmp_file}"
		fi
		unset atom atom_opts option options uses comment
	done
	cp "${tmp_file}" "${striped}" 2>/dev/null

	while read atom opt;do
		[[ -z "${opt}" ]] && sed -e "s|^${atom} ||" -i "${striped}" 2>/dev/null
		unset atom opt
	done < "${tmp_file}"
	sed -e 's/[ \t]*$//' -e '/^$/d' -e 's|  | |g' -e "s| - | |g" -i "${striped}" 2>/dev/null
	sort -u "${striped}" -o "${striped}" 2>/dev/null
	rm "${tmp_file}" 2>/dev/null
	diff_ask "${file}" "${striped}"
	eend $? 2>/dev/null
} 2>/dev/null
############################################################################
################ package.use ###############################################
sort_use_file(){
	file_or_dir "package.use" "Sorting use flags in" "sort_uses" || return 1
}
############################################################################
################ one_keyword ###############################################
sort_keywords(){
	keys(){
		tmp_file="$(mktemp)"
		atoms="$(awk '{print $1}' "${file}" | sort -u)"
		while read atom;do
			comment="$(grep "${atom}[[:space:]].*#" "${file}" | cut -d\# -f2-)"
			keyword="$(grep "${atom}[[:space:]]" ${file} | sed -e "s|${atom} ||" -e "s|#.*${comment}||" |\
						tr "[:space:]" $'\n' | sed '/^$/d' | tail -n1)"
			if [[ -n "${comment}" ]];then
				echo "${atom} ${keyword} #${comment}" >> "${tmp_file}"
			else
				echo "${atom} ${keyword}" >> "${tmp_file}"
			fi
		done <<< "${atoms}"
		sort -u "${tmp_file}" -o "${tmp_file}" 2>/dev/null
		diff_ask "${file}" "${tmp_file}"
		eend $? 2>/dev/null
	}
	file_or_dir "package.keywords package.accept_keywords" "Sorting keywords in" "keys" || return 1
}
############################################################################
################ uniq_keyword ##############################################
uniq_keywords(){
	file_or_dir "package.keywords package.accept_keywords" "Sorting keywords in" "set -f" "sort_uses" "set +f" || return 1
}
############################################################################
################ not_installed #############################################
installed(){
installed="$(LANG=en eix --xml --end --installed "${category}/${pn}" 2>/dev/null | grep "version id=")"
if [[ -n "${installed}" ]];then
	installed_vers="$(awk -F \" '{print $2}' <<< "${installed}")"
	installed_min_ver="$(head -n1 <<< "${installed_vers}")"
	installed_max_ver="$(tail -n1 <<< "`grep -v 9999 <<< ${installed_vers}`")"
	installed_live_ver="$(tail -n1 <<< "`grep 9999 <<< ${installed_vers}`")"
	grep -q "slot=" <<< "${installed}" && installed_slots="$(awk -F \" '{print $4}' <<< "${installed}")"
fi
}
##########################################
not_if(){
	atoms="$(awk '{print $1}' <<< "`grep -v "^#" < ${package}`")"
	[[ -n "${IGNORE}" ]] && atoms="$(grep -v "${IGNORE}" <<< "${atoms}")"
	echo -e "${underline}Checking${restore} ${contrast}$package${restore}"
	if [[ -n "${atoms}" ]];then
		while read atom;do
			while read category pn ver rev slot;do
				sw="$(sed -e 's|^=|= |g;s|^>=|>= |g;s|^>|> |g;s|<|< |g;s| <|<|g;s| =|=|g;s|~|~ |g;s|=|= |g' <<< "${category}")"
				if [[ "${category}" == "${sw}" ]];then
					unset sw
				else
					sw="$(awk '{print $1}' <<< "${sw}")"
					category="${category##${sw}}"
				fi

				[[ "${category}" == "(null)" || "${pn}" == "(null)" ]] && continue

				if [[ -n "${rev}" ]] && [[ -z "${slot}" ]] && `grep -q \: <<< "${rev}"`;then
					slot="${rev}"
					unset rev
				fi
				slot="${slot#:}"
				pn="${pn%:}"
				installed;

				if [[ -z "${installed}" ]];then
					echo -e "${red}Not installed${restore} ${green}${category}/${pn}${restore}"
					sed -e "s|.*\<${category}/${pn}\>.*||" -e '/^$/d' -i "${tmp_package}" 2>/dev/null
					eend $? 2>/dev/null
				fi
			done <<< `qatom "${atom}"`
		done <<< "${atoms}"
	fi
}
##########################################
force_not_installed(){
for package in `find ${PORT_ETC}/package* -type f \! -name '*~' \! -name '*.bak'`;do
	if [[ -s "${package}" && -n "$(grep -v "^#" < "${package}")" ]];then
		tmp_package="$(mktemp)"
		cp "${package}" "${tmp_package}"
		if ! `grep -q "\.mask" <<< "${package}"`;then
			not_if;
			eend $? 2>/dev/null
		fi
		diff_ask "${package}" "${tmp_package}"
	else
		pack="${package%/*}"
		echo -e "${underline}Empty file${restore} ${contrast}${pack}${restore}"
		remove_ask "${package}"
		eend $? 2>/dev/null
	fi
done

for x in `find ${PORT_ETC}/package* -type f`;do
	if [[ ! -s "${x}" ]];then
		echo -e "${underline}Empty file${restore} ${contrast}${x}${restore}"
		remove_ask "${x}"
		eend $? 2>/dev/null
	fi
done
}
############################################################################
################ package.env workaround ####################################
package_env(){
for package in `find ${PORT_ETC}/ -name "package.*" \! -name '*~' \! -name '*.bak'`;do
	if [[ "${package##*/}" == "package.env" ]];then
		if [[ -f "${package}" ]];then
			while read line;do
				atom="${line%% *}"
				for conf in ${line#${atom} };do
					[[ -f "${PORT_ETC}/env/${conf}" ]] && IGNORE="${IGNORE}
${conf}"
				done
			done < "${package}"
		elif [[ -d "${package}" ]];then
			for subpackage in `find "${package}" -type f \! -name '*~' \! -name '*.bak'`;do
				while read line;do
					atom="${line%% *}"
					for conf in ${line#${atom} };do
						[[ -f "${PORT_ETC}/env/${conf}" ]] && IGNORE="${IGNORE}
${conf}"
					done
				done < "${subpackage}"
			done
		fi
	fi
done
}
############################################################################
################ env not_installed #########################################
env_not_installed(){
echo -e "${underline}Looking not installed in ${restore} ${contrast}${PORT_ETC}/env${restore}"
package_env;
for x in "env" "env.d";do
	files="$(find ${PORT_ETC}/${x}/ -mindepth 2 -maxdepth 2 -type f \! -name '*~' \! -name '*.bak' 2>/dev/null| cut -d\/ -f5-)"
	[[ -n "${IGNORE}" ]] && files="$(grep -v "${IGNORE}" <<< "${files}")"
	dirs="$(find ${PORT_ETC}/${x}/ -type d 2>/dev/null)"
	[[ -n "${IGNORE}" ]] && dirs="$(grep -v "${IGNORE}" <<< "${dirs}")"
	[[ -n "${files}" || -n "${dirs}" ]] || break
	
	while read file;do
		atom="$(qatom "${file}")"
		atom="$(sed -e '/^$/d' <<< "${atom}")"
		while read category pn ver rev slot;do
			[[ "${category}" == "(null)" || "${pn}" == "(null)" ]] && continue
			[[ "${ver}" == "(null)" ]] && ver="${ver//(null)/}"
			if [[ -n "${rev}" ]] && ! `grep -q \: <<< "${rev}"`;then
				full_ver="${ver}-${rev}"
			else
				full_ver="${ver}"
			fi

			if [[ -n "${rev}" ]] && [[ -z "${slot}" ]] && `grep -q \: <<< "${rev}"`;then
				slot="${rev}"
			fi
			slot="${slot#:}"

			if [[ -z "${ver}" ]] && [[ -z "${slot}" ]];then
				if ! `ls -d1 ${PKGDB}/${category}/${pn}-[0-9]* &>/dev/null`;then
					echo -e "${red}Not installed${restore} ${green}${category}/${pn}${restore}"
					RM+="${PORT_ETC}/${x}/${file}%"
					eend $? 2>/dev/null
				fi
			fi

			if [[ -n "${ver}" ]] && [[ -z "${slot}" ]] ;then
				if ! `ls -d1 ${PKGDB}/${category}/${pn}-${full_ver} &>/dev/null`;then
					echo -e "${red}Not installed${restore} ${green}${category}/${pn}-${full_ver}${restore}"
					RM+="${PORT_ETC}/${x}/${file}%"
					eend $? 2>/dev/null
				fi
			fi

			if [[ -z "${ver}" ]] && [[ -n "${slot}" ]] ;then
				if [[ -z "$(cat ${PKGDB}/${category}/${pn}-[0-9]*/SLOT 2>/dev/null | grep ${slot})" ]];then
					echo -e "${red}Not installed${restore} ${green}${category}/${pn}:${slot}${restore}"
					RM+="${PORT_ETC}/${x}/${file}%"
					eend $? 2>/dev/null
				fi
			fi
		done <<< "${atom}"
	done <<< "${files}"

	IFS="%"
	for target in ${RM%\%};do
		remove_ask "${target}"
	done
	IFS=$'\n'
	for target in ${dirs};do
		[[ -z "`ls ${target}`" ]] && remove_ask "${target}"
	done
unset IFS
done
eend $? 2>/dev/null
}
############################################################################
################ incorrect uses ############################################
invalid_uses(){
	FULL="${PROFILE} ${MAKE_USES}"
	for opt in ${FULL};do
		GLOBAL+=" $(echo ${FULL} | tr "[:space:]" $'\n' | grep -e "^${opt#-}$" -e "^\-${opt#-}$" | tail -n1)"
	done
	GLOBAL="$(echo ${GLOBAL} | tr "[:space:]" $'\n' | sort -u)"
############################################################################
check_uses(){
	echo -e "${underline}Checking use flags in${restore} ${contrast}${file#${PORT_ETC}/}${restore}:"
	##### eix env #####
	export OVERLAYS_LIST="no"
	export FORMAT='<availableversions:USEONLY>'
	export USEONLY=' <use>'

	while read category pn ver slot;do
	#### just count
		tput sc
		tput civis
		echo -ne "["; printf "% ${chars}d" $((count--));echo -ne " ]" "atoms left" 2>/dev/null
		tput rc

		ALL_USE=" $(eix --end "${category}/${pn}")" || continue
		ALL_USE="$(echo -e "${ALL_USE}" | sed -e 's| +| |g;s| -| |g;s|(+)||g' | tr "[:space:]" $'\n' | sort -u | sed -e '/^$/d')"
		LOCAL="$(grep "\<${category}/${pn}\> " "${file}" | cut -d" " -f2- | sed -e "s|#.*||g" | tr "[:space:]" $'\n' | sort -u)"
		USES="$(sed -e 's|^-||g' <<< "${LOCAL}")"
		for use in ${USES};do
			if ! grep -q "^${use}$" <<< "${ALL_USE}";then
				grep -q " ${use}\>" <<< "${incorrect_use}" || incorrect_use="${incorrect_use} ${use}"
			else
				incorrect_use="${incorrect_use// ${use}/}"
			fi

			if grep -q "^${use}$" <<< "${GLOBAL}" && grep -q "^${use}$" <<< "${LOCAL}";then
				global_use="${global_use} ${use}"
			elif grep -q "^\-${use}$" <<< "${GLOBAL}" && grep -q "^\-${use}$" <<< "${LOCAL}";then
				global_use="${global_use} -${use}"
				incorrect_use="${incorrect_use// ${use}/}"
			fi
		done

		incorrect_use="$(echo ${incorrect_use} | tr "[:space:]" $'\n' | sed -e 's|  | |g' -e '/^ $/d' -e '/^$/d' | sort -u)"
		global_use="$(echo ${global_use} | tr "[:space:]" $'\n' | sed -e 's|  | |g' -e '/^ $/d' -e '/^$/d' | sort -u)"
		if [[ -n "${incorrect_use}" ]];then
			while read trash;do
				echo -e "Invalid use: ${green}${category}/${pn}${restore}: ${red}${trash}${restore}"
				strings="$(grep "^${category}/${pn}[[:space:]].*\<${trash}\>" ${tmp_file})"
				while read string;do
					struse="${string#${category}/${pn}}"
					struse="$(tr "[:space:]" $'\n' <<< ${struse})"
					usefxd="$(sed -e "s|^${trash#-}$||" -e "s|^\-${trash#-}$||" -e '/^$/d' <<< "${struse}")"
					usefxd="$(tr $'\n' " " <<< "${usefxd}")"
					usefxd="$(sed -e 's| - | |g' -e 's/[ -]*$//' <<< ${usefxd})"
					strfxd="${category}/${pn} ${usefxd}"
					sed -e "s|^${category}/${pn}[[:space:]].*${trash#-}.*|$strfxd|" -i ${tmp_file} 2>/dev/null
					eend $? 2>/dev/null
				done <<< "${strings}"
			done <<< "${incorrect_use}"
		fi
		if [[ -n "${global_use}" ]];then
			while read trash;do
				echo -e "Global  use: ${green}${category}/${pn}${restore}: ${red}${trash}${restore}"
				strings="$(grep "^${category}/${pn}[[:space:]].*\<${trash#-}\>" ${tmp_file})"
				while read string;do
					struse="${string#${category}/${pn}}"
					struse="$(tr "[:space:]" $'\n' <<< ${struse})"
					usefxd="$(sed -e "s|^${trash#-}$||" -e "s|^\-${trash#-}$||" -e '/^$/d' <<< "${struse}")"
					usefxd="$(tr $'\n' " " <<< "${usefxd}")"
					usefxd="$(sed -e 's| - | |g' -e 's/[ -]*$//' <<< ${usefxd})"
					strfxd="${category}/${pn} ${usefxd}"
					sed -e "s|^${category}/${pn}[[:space:]].*${trash#-}.*|$strfxd|" -i ${tmp_file} 2>/dev/null
					eend $? 2>/dev/null
				done <<< "${strings}"
			done <<< "${global_use}"
		fi
		unset ALL_USE LOCAL USES incorrect_use global_use use
	done <<< "`[[ -n "${atoms}" ]] && echo -e "${atoms}"`"
	while read atom opt;do
		if [[ -n "${atom}" ]] && [[ -z "${opt}" ]];then
			echo -e "Removing atom: ${green}${atom}${restore}"
			sed -e "s|^${atom} *$||" -e '/^$/d' -i "${tmp_file}" 2>/dev/null
			eend $? 2>/dev/null
		fi
	done <<< "$([[ -n "${IGNORE}" ]] && grep -v "${IGNORE}" < "${file}" || cat "${file}")"
	while read atom opt;do
		if [[ -n "${atom}" ]] && [[ -z "${opt}" ]];then
			echo -e "Removing atom: ${green}${atom}${restore}"
			sed -e "s|^${atom} *$||" -e '/^$/d' -i "${tmp_file}" 2>/dev/null
			eend $? 2>/dev/null
		fi
	done <<< "$([[ -n "${IGNORE}" ]] && grep -v "${IGNORE}" < "${tmp_file}" || cat "${tmp_file}")"
	eend $? 2>/dev/null
	unset FORMAT USEONLY
}
if [[ -f "${PORT_ETC}/package.use" ]];then
	file="${PORT_ETC}/package.use"
	tmp_file="$(mktemp)"
	cp "${file}" "${tmp_file}"
	if [[ -n "${IGNORE}" ]];then
		content="$(awk '{print $1}' ${file} | tr -d "<>=~" | sed -e 's|^#.*||g' | grep -v "${IGNORE}")"
		[[ -n "${content}" ]] && atoms="$(qatom ${content})"
	else
		content="$(awk '{print $1}' ${file} | tr -d "<>=~" | sed -e 's|^#.*||g')"
		[[ -n "${content}" ]] && atoms="$(qatom ${content})"
	fi
	count="$(wc -l <<< "${atoms}")"
	((count--))
	chars="$(wc -m <<< "${count}")"
	check_uses;
	tput el;
	tput cnorm;
	diff_ask "${file}" "${tmp_file}"
	[[ ! -s "${file}" ]] && remove_ask "${file}"
elif [[ -d "${PORT_ETC}/package.use" ]];then
	for f in `find ${PORT_ETC}/package.use/ -type f \! -name '*~' \! -name '*.bak'`;do
		if [[ -s "${f}" ]];then
			file="${f}"
			tmp_file="$(mktemp)"
			cp "${file}" "${tmp_file}"
			if [[ -n "${IGNORE}" ]];then
				content="$(awk '{print $1}' ${file} | tr -d "<>=~" | sed -e 's|^#.*||g' | grep -v "${IGNORE}")"
				[[ -n "${content}" ]] && atoms="$(qatom ${content})"
			else
				content="$(awk '{print $1}' ${file} | tr -d "<>=~" | sed -e 's|^#.*||g')"
				[[ -n "${content}" ]] && atoms="$(qatom ${content})"
			fi
			count="$(wc -l <<< "${atoms}")"
			((count--))
			chars="$(wc -m <<< "${count}")"
			check_uses;
			tput cnorm
			diff_ask "${file}" "${tmp_file}"
			[[ ! -s "${file}" ]] && remove_ask "${file}"
		else
			echo -e "${underline}Removing empty file${restore} ${contrast}${f}${restore}"
			rm ${f} 2>/dev/null
			eend $? 2>/dev/null
			continue
		fi
	done
fi
tput cnorm
}
############################################################################
################ incorrect uses in make.conf ###############################
make_conf_use() {
	defined_flags="$(grep "${1}=\".*\"" ${makefile})"
	[[ -z "${defined_flags}" ]] && defined_flags="$(sed -ne "/${1}=\"/,/\"/p" ${makefile})"
	echo "${defined_flags}"
}

hell_parser(){
	sed -e 's|[[:space:]]| |g' -e :a -e '/\\$/N; s/\\\n//; ta' | \
	cut -d\" -f2 | tr "[[:space:]]" $'\n' | sed '/^$/d;s|^-||g'  | sort -u
}

invalid_uses_make(){
	[[ -f "/etc/make.conf" ]] && makefile="/etc/make.conf"
	[[ -f "${PORT_ETC}/make.conf" ]] && makefile="${PORT_ETC}/make.conf"
	echo -e "${underline}Checking use flags in${restore} ${contrast}${makefile}${restore}"
	tmp_file="$(mktemp)"
	cp "${makefile}" "${tmp_file}"

	vars_in_USE="$(make_conf_use USE | hell_parser | grep '\$' | tr -d '${}')"
	real_uses="$(eix --print-all-useflags | sed 's|^[-+]||g;s|^(+)||g' | sort -u)"
	for var in ${vars_in_USE} USE;do
		sub_uses="$(make_conf_use ${var} | hell_parser | grep -v '\$')"
		for use in ${sub_uses};do
			if ! grep -q "^${use}$" <<< "${real_uses}";then
				echo -ne "Invalid use ${contrast} ${var}: ${red}${use}${restore}" | column -t
				invalid_uses+=" ${use}"
			fi
		done
	done

	if [[ -n "${invalid_uses}" ]];then
		for iuse in ${invalid_uses};do
			line="$(grep "\<${iuse}\>" ${tmp_file})"
			fixed_line="$(sed "s|[- \t]${iuse}||" <<< "${line}")"
			sed -e "s|${line%\\}|${fixed_line%\\}|" -i "${tmp_file}"
		done
	fi
	diff_ask "${makefile}" "${tmp_file}"
}
############################################################################
################ not_found #################################################
not_found(){
	TRASH="$(LANG=en eix -Ttc 2>/dev/null)"
	for package in `ls -d1 ${PORT_ETC}/package* | grep -v "~"`;do
		incorrect="$(echo -e "${TRASH}" | tr $'\n' "%" | sed -e "s|.*${package}:||" -e 's|--.*||' -e 's|No.*||'|\
		tr "%" $'\n' | sed -e '/^$/d' | grep -v "${IGNORE}")"
		if [[ -n "${incorrect}" && -f "${package}" ]];then
			tmp_package="$(mktemp)"
			cp "${package}" "${tmp_package}"
			echo -e "${underline}Removing incorrect from${restore} ${contrast}${package}${restore}:"
			while read line;do
				echo -e "${red}Incorrect:${restore} ${line}"
				line="${line//'*'/\*}"
				[[ -n "${line}" ]] && sed -e "s|$line||" -e 's/[ \t]*$//' -e '/^$/d' -i ${tmp_package} 2>/dev/null
				eend $? 2>/dev/null
			done <<< "${incorrect}"
			diff_ask "${package}" "${tmp_package}"
		elif [[ -n "${incorrect}" && -d "${package}" ]];then
			echo -e "${underline}Removing incorrect from${restore} ${contrast}${package}${restore}:"
			IFS=$'\n'
			for line in ${incorrect};do
				for file in `grep -RH "${line//'*'/\*}" "${package}"/ | awk -F \: '{print $1}'`;do
					tmp_file="$(mktemp)"
					cp "${file}" "${tmp_file}"
					echo -e "${red}Incorrect:${restore} ${line}"
					[[ -n "${line}" ]] && sed -e "s|${line//'*'/\*}||" -e 's/[ \t]*$//' -e '/^$/d' -i ${tmp_file}
					diff_ask "${file}" "${tmp_file}"
					eend $? 2>/dev/null
				done
			done
			unset IFS
		fi
	done

	INVALID="$(LANG=en eix -Ttc 2>&1 | grep "Invalid.*\'.*\'" | grep -v '\.\.\.' | sort -u)"

	IFS=$'\n'
	for string in ${INVALID};do
		[[ -z "${string}" ]] && break
		file="$(awk -F ':' '{print $1}' <<< "${string}")"
		file="${file##* }"
		file="${file//[[:space:]]/}"

		line="$( awk -F ':' '{print $2}' <<< "${string}")"
		line="${line//\'/}"
		echo -e "${red}Incorrect:${restore} ${line}"
		line="${line//'*'/\*}"
		line="${line#[[:space:]]}"

		if [[ -n "${line}" && -f "${file}" ]];then
			tmp_file="$(mktemp)"
			cp "${file}" "${tmp_file}"
			[[ -n "${line}" ]] && sed -e "s|`echo $line`$||" -e 's|[ \t]| |' -e '/^[ \t]$/d' -e '/^$/d' -i ${tmp_file}
			diff_ask "${file}" "${tmp_file}"
		elif [[ -n "${line}" && -d "${file}" ]];then
			for package in `grep -RH "${line//'*'/\*}" "${file}"/ | awk -F \: '{print $1}'`;do
					tmp_package="$(mktemp)"
					cp "${package}" "${tmp_package}"
					echo -e "${red}Incorrect:${restore} ${line}"
					[[ -n "${line}" ]] && sed -e "s|${line//'*'/\*}||" -e 's/[ \t]*$//' -e '/^$/d' -i ${tmp_package}
					diff_ask "${package}" "${tmp_package}"
					eend $? 2>/dev/null
			done
		fi
		eend $? 2>/dev/null
	done
	unset IFS
}
############################################################################
################ profile's uses in make.conf ###############################
use_makeconf(){
	[[ -f "/etc/make.conf" ]] && makefile="/etc/make.conf"
	[[ -f "${PORT_ETC}/make.conf" ]] && makefile="${PORT_ETC}/make.conf"
	echo -e "${underline}Checking use flags in${restore} ${contrast}${makefile##/etc*/}${restore}"
	USE="$(echo -e "${MAKE_USES}" | tr "[:space:]" $'\n' | sort -u | sed -e '/^$/d')"

	tmp_file="$(mktemp)"
	cp "${makefile}" "${tmp_file}"
	while read use;do
		flag="${use#-}"
		if [[ -n ${flag} ]];then
			if grep -q "^${flag}$" <<< "${USE}" && grep -q "^${flag}$" <<< "${PROFILE}";then
				echo -e "Twice defined: ${red}${use}${restore}"
				sed -e "s|[^[:punct:]]\<${flag}\>||g" -i ${tmp_file}
			elif grep -q "^\-${flag}$" <<< "${USE}" && grep -q "^\-${flag}$" <<< "${PROFILE}";then
				echo -e "Twice defined: ${red}-${use}${restore}"
				sed -e "s|[^[:punct:]]\-\<${flag}\>||g" -i ${tmp_file}
			fi
		fi
	done <<< "${PROFILE}"
	diff_ask "${makefile}" "${tmp_file}"
	eend $? 2>/dev/null
}
############################################################################
################ empty files ###############################################
empty_files(){
	echo -e "${underline}Looking empty files${restore}"
	for target in `find ${PORT_ETC} -type f`;do
		[[ ! -s "${target}" || -z "$(grep -v "^#" < "${target}")" ]] && remove_ask "${target}"
	done
	eend 0 2>/dev/null
}
############################################################################
################ package.* files 2 dirs ####################################
f_to_d(){
	while read package;do
		if [[ -f "${package}" ]];then
			echo -e "${underline}Processing${restore}: ${contrast}${package##*/}${restore}"
			tmp_file="$(mktemp)"
			mv ${package} ${tmp_file} 2>/dev/null
			sed -e 's|^#.*||g' -i "${tmp_file}"
			dir="${PORT_ETC}/${package##*/}"
			mkdir "${dir}"
			while read line;do
				atom="$(awk '{print $1}' <<< "${line}")"
				category="$(awk '{print $1}' <<< `qatom ${atom}`)"
				if [[ "${category}" != "(null)" ]];then
					category="$(tr -d "<>=~" <<< "${category}" )"
					echo "${line}" >> "${dir}/${category}"
				fi
			done < "${tmp_file}"
			eend $? 2>/dev/null
			rm "${tmp_file}" 2>/dev/null
		elif [[ -d "${package}" ]];then
			echo -e "${underline}Skipping ${red}directory${restore}: ${contrast}${package##*/}${restore}"
			eend $? 2>/dev/null
		fi
	done <<< "`ls -d1 ${PORT_ETC}/package* | grep -v "~"`"
}
############################################################################
################ package.* dirs 2 files ####################################
d_to_f(){
	while read package;do
		if [[ -d "${package}" ]];then
			echo -e "${underline}Processing${restore}: ${contrast}${package##*/}${restore}"
			tmp_file="$(mktemp)"
			file="${PORT_ETC}/${package##*/}"
			touch "${file}"
			for subfile in `find "${package}" -type f \! -name '*~' \! -name '*.bak' | sort`;do
				while read line;do
					echo "${line}" >> "${tmp_file}"
				done < "${subfile}"
			done
			rm -rf "${package}" 2>/dev/null
			mv "${tmp_file}" "${package}" 2>/dev/null
			eend $? 2>/dev/null
			rm "${tmp_file}" 2>/dev/null
		elif [[ -f "${package}" ]];then
			echo -e "${underline}Skipping ${red}file${restore}: ${contrast}${package##*/}${restore}"
			eend $? 2>/dev/null
		fi
	done <<< "`ls -d1 ${PORT_ETC}/package* | grep -v "~"`"
}
############################################################################
################ version diff ##############################################
ver_diff(){
	check="$(versionsort ${1} ${2} 2>/dev/null | tail -n1)"
	[[ "${check}" == "${1}" && "${check}" != "${2}" ]] && echo 1 # ${1} > ${2}
	[[ "${check}" == "${2}" && "${check}" != "${1}" ]] && echo 2 # ${2} > ${1}
	[[ "${check}" == "${1}" && "${check}" == "${2}" ]] && echo 0 # ${1} == ${2}
}
############################################################################
################ version between ###########################################
ver_btwn(){
	for between in ${3};do
		if [[ "$(ver_diff "${1}" "${between}")" == "1" && "$(ver_diff "${2}" "${between}")" == "2" ]];then
			echo "1" # we have one_or_more version between ${1} and ${2}
			break
		fi
	done
}
############################################################################
package_envs(){
	for atom in ${1};do
		while read category pn ver rev slot;do
			sw="$(sed -e 's|^=|= |g;s|^>=|>= |g;s|^>|> |g;s|<|< |g;s| <|<|g;s| =|=|g;s|~|~ |g;s|=|= |g' <<< "${category}")"
			if [[ "${category}" == "${sw}" ]];then
				sw="(null)"
			else
				sw="$(awk '{print $1}' <<< "${sw}")"
				category="${category##${sw}}"
			fi
			[[ "${category}" == "(null)" || "${pn}" == "(null)" ]] && continue
			if [[ -n "${rev}" && -z "${slot}" ]] && grep -q \: <<< "${rev}";then
				slot="${rev}"
				unset rev
			fi
			slot="${slot#:}"
			pn="${pn%:}"
			[[ -z "${rev}" ]] && rev="(null)"
			[[ -z "${slot}" ]] && slot="(null)"
			echo "${sw} ${category} ${pn} ${ver} ${rev} ${slot} ${file}"
		done <<< `qatom "${atom}"`
	done
}
############################################################################
################ mask/unmask trash #########################################
all_mask_trash(){
	mask_trash(){
		masked="$(awk '{print $1}' ${file} | grep -v '^#.*')"
		MASKED+="$(package_envs "${masked}")"$'\n'
	}
	file_or_dir "package.mask" "Preparing atoms in" "mask_trash" || return 1
	unmask_trash(){
		unmasked="$(awk '{print $1}' ${file} | grep -v '^#.*')"
		UNMASKED+="$(package_envs "${unmasked}")"$'\n'
	}
	file_or_dir "package.unmask" "Preparing atoms in" "unmask_trash" || return 1
}
mask_trash(){
	slot_output(){
		if [[ "${mslot}" != "(null)" ]];then
			echo -e "${red}Incorrect${restore}: ${mcategory}/${mpn}:${mslot}"
		else
			echo -e "${red}Incorrect${restore}: ${mcategory}/${mpn}"
		fi
		TRASH+="${mfile} ${mcategory}/${mpn}"$'\n'
		unset msw mcategory mpn mver mrev mslot mfile usw ucategory upn uver urev uslot ufile
		continue
	}
	non_slot_output(){
		echo -e "${red}Incorrect${restore}: ${msw}${mcategory}/${mpn}-${mver}"
		TRASH+="${mfile} ${msw}${mcategory}/${mpn}-${mver}"$'\n'
		unset msw mcategory mpn mver mrev mslot mfile usw ucategory upn uver urev uslot ufile
		continue
	}
	all_mask_trash || return 1
	###### m->masked; u->unmasked
	while read msw mcategory mpn mver mrev mslot mfile;do
		while read usw ucategory upn uver urev uslot ufile;do
			[[ "${mrev}" == "(null)" ]] && unset mrev || mver="${mver}-${mrev}"
			[[ "${urev}" == "(null)" ]] && unset urev || uver="${uver}-${urev}"
			[[ "${mver}" == "(null)" ]] && unset mver
			[[ "${uver}" == "(null)" ]] && unset uver

			if [[ -n "${mver}" || -n "${uver}" ]];then
				export OVERLAYS_LIST="no"
				export VERSIONONLY='<version> '
				export FORMAT='<availableversions:VERSIONONLY>'
				versions="$(eix -e "${mcategory}/${mpn}")"
				oldest="$(awk '{print $1}' <<< "${versions}")"
			fi

			if [[ -n "${mver}" && -n "${uver}" ]];then
				versions_diff="$(ver_diff "${mver}" "${uver}")"
				versions_btwn="$(ver_btwn "${uver}" "${mver}" "${versions}")"
			fi

			if [[ "${msw}" != "(null)" ]];then
				if [[ "${usw}" == "(null)" && "${uslot}" == "(null)" ]];then
					non_slot_output
				elif [[ "${msw}" == ">" || "${msw}" == ">=" ]];then
					if [[ "${usw}" == ">" || "${usw}" == ">=" ]];then
						if [[ "${versions_diff}" != "1" && -z "${versions_btwn}" ]];then
							non_slot_output
						fi
					fi
				elif [[ "${msw}" == "<" || "${msw}" == "<=" ]];then
					if [[ "${usw}" == "<" || "${usw}" == "<=" ]];then
						if [[ "${versions_diff}" != "1" ]];then
							non_slot_output
						fi
					fi
				fi
			else
				if [[ "${mslot}" == "${uslot}" ]];then
					if [[ "${usw}" == ">=" || "${usw}" == ">" ]];then
						if [[ "$(ver_diff "${uver}" "${oldest}")" != "1" ]];then
							slot_output
						fi
					elif [[ "${usw}" == "<"  && "$(ver_diff "${uver}" "${oldest}")" == "1" ]];then
						slot_output
					elif [[ "${usw}" == "<=" && "$(ver_diff "${uver}" "${oldest}")" != "1" ]];then
						slot_output
					elif [[ "${usw}" == "(null)" ]];then
						slot_output
					fi
				fi
			fi
		done <<< "`grep " ${mcategory} ${mpn} " <<< "${UNMASKED}"`"
	done <<< "${MASKED}"

	files="$(awk '{print $1}' <<< "${TRASH}" | sort -u)"
	for target in ${files};do
		tmp_file="$(mktemp)"
		cp "${target}" "${tmp_file}"
		incorrect="$(grep ${target} <<< "${TRASH}" | sed -e "s|${target} ||g")"
		for trash_atom in ${incorrect};do
			sed -e "s|^${trash_atom}.*||" -e '/^$/d' -e 's/[ \t]*$//' -i "${tmp_file}"
		done
	diff_ask "${target}" "${tmp_file}"
	done
	unset TRASH OVERLAYS_LIST VERSIONONLY FORMAT MASKED UNMASKED versions oldest versions_diff versions_btwn
}
############################################################################
################ looking trash #############################################
remove_trash(){
	tmp_file="$(mktemp)"
	cp "${file}" "${tmp_file}"
	for atom in `eix -Tc#`;do
		lines="$(grep "${atom}" "${file}")"
		while read line;do
			entry="$(qatom "$(tr -d '<>=~#' <<< "${line}")" | awk '{print $1,$2}' | tr ' ' '/')"
			if [[ "${atom}" == "${entry}" ]];then
				if `eix -Iqe ${atom}`;then
					echo -e "stupid entry:              ${green}${line}${restore}"
				else
					echo -e "stupid entry (${red}!${restore}installed): ${green}${line}${restore}"
				fi
				sed -e "s|${line}||" -e '/^$/d' -i "${tmp_file}"
				break
			fi
		done <<< "${lines}"
	done
	diff_ask "${file}" "${tmp_file}"
	eend $? 2>/dev/null
}
############################################################################
################ stupid unmask #############################################
stupid_unmask(){
	export REDUNDANT_IF_IN_UNMASK="all"
	export REDUNDANT_IF_IN_MASK="no"
	export TEST_FOR_NONEXISTENT="true"
	export REDUNDANT_IF_UNMASK_NO_CHANGE="all"
	file_or_dir "package.unmask" "Checking stupid unmasks:" "remove_trash" || return 1
	unset REDUNDANT_IF_IN_UNMASK REDUNDANT_IF_IN_MASK TEST_FOR_NONEXISTENT REDUNDANT_IF_UNMASK_NO_CHANGE
}
############################################################################
################ regen_world ###############################################
regen_world(){
	tmp_world="$(mktemp)"
	ex_world="$(mktemp)"
	mv "${WORLD}" "${ex_world}"
	installed="$(qlist -CI | sort -u)"
	echo "${installed}" > "${WORLD}"
	echo -e "Calculating dependencies"

	pretend="$(emerge -eopd --columns --with-bdeps=y world 2>/dev/null | grep -v "blocks" | awk '/^\[/ {print $4}')" && eend 0 2>/dev/null
	pretend+="$(qlist -CI `emerge -epO system | awk '/\[/ {print $4}'`)"$'\n'

	for atom in ${installed};do
		if ! grep -q "^${atom}$" <<< "${pretend}" && ! grep -q ".*-libs/" <<< "${atom}";then
				echo "${atom}" >> "${tmp_world}"
				echo -e "world++: ${green}${atom}${restore}"
		fi
	done
	cp "${tmp_world}" "${WORLD}"

	PS3=`echo -e "${contrast}Choose package which you want save:${restore} "`
	choose_target(){
		select target in ${pretend};do
			echo "=${target}"
			break
		done
	}
	add_in_world(){
		notrash_pkgs+=" $(choose_target)"
		for tp in ${notrash_pkgs};do
			pretend="$(sed -e "s|^${tp#=}$||" -e '/^$/d' <<< "${pretend}")"
		done
	}
	ask(){
		pretend="$(emerge -pc | grep 'All selected packages:' | sed 's|.*:||1' | tr ' ' $'\n')"
		echo -e "\n${pretend// /$'\n'}"
		if [[ -n "$(sed '/^$/d' <<< "${pretend}")" ]];then
			echo -ne "\n${contrast}Would you like save some packages?${restore} [${green}Yes${restore}/${red}No${restore}] "
			while read x;do
				[[ -z "$(sed '/^$/d' <<< "${pretend}")" ]] && break
				case ${x} in
					Yes | YES | yes | Y | y | "" )
						add_in_world;
						while [[ -z "${enough}" && "$(echo "${pretend// /$'\n'}" | sed '/^$/d' | wc -l)" != "0" ]];do
							echo -ne "${contrast}More?${restore} [${green}Yes${restore}/${red}No${restore}] "
							while read y;do
								case ${y} in
									Yes | YES | yes | Y | y | "" )
										add_in_world;
										break;;
									No | NO | no | N | n )
										enough="1"
										break;;
									* ) echo -ne "Sorry, response '${y}' not understood. [${green}Yes${restore}/${red}No${restore}] "
										continue;;
								esac
							done
						done
						break;;
					No | NO | no | N | n )
						break;;
					* ) echo -ne "Sorry, response '${x}' not understood. [${green}Yes${restore}/${red}No${restore}] "
						continue;;
				esac
			done
			[[ -n "$(sed '/^$/d' <<< "${notrash_pkgs}")" ]] && emerge -Own ${notrash_pkgs}
		else
			return 0
		fi
	}
	for t in 1 2;do
		[[ "${t}" == "1" ]] && echo -e "\nemerge -pc: ${green}check...${restore}"
		[[ "${t}" == "2" ]] && echo -e "\nemerge -pc: ${green}recheck...${restore}"
		ask
		unset enough
	done
	cp "${WORLD}" "${tmp_world}"
	cp "${ex_world}" "${WORLD}"
	diff_ask "${WORLD}" "${tmp_world}"
	eend $? 2>/dev/null
}
############################################################################
################ help ######################################################
help_pc(){
echo -e \
"Usage: portconf [OPTION] [OPTION]â€¦[OPTION]
available OPTIONS:
${contrast}Common${restore}:
	--regen-cache, -rc:          Create and use temporary eix-cache and some fix for overlays. ${red}Highly recommend!${restore}
	--backup, -b:                Create backup for current /etc/portage state.
	--restore, -r:               Rolling up /etc/portage to one of available states.
	--sort, -s:                  Sort entries alphabetically, --use-sort, --keyword-uniq.
	--yes, -y:                   Auto answer (Yes).
	--pretend, -p:               Check only.
	--help, -h, -?, h:           This help.
${contrast}\${USE}${restore}:
	--use-sort, -us:             Sort useflags. Remove doubles and preserve only last defined state (on/off).
	--use-invalid, -ui:          Delete invalid or twice global-defined useflags.
	--use-make, -um:             Delete profile defined useflags from make.conf.
	--use-full, -uf:             An analog '-us -ui -um'.
${contrast}\${KEYWORDS}${restore}:
	--keyword-uniq, -ku:         Like '-us', but for keywords.
	--keyword-one, -ko:          Save only latest defined keyword.
${contrast}Trash${restore}:
	--trash, -t:                 Delete not_founded/not_installed entries.
	--force-trash, -ft:          Delete all not_installed entries.(exclude package.mask file/dir)
	--stupid-mask, -sm           Remove incorrect masked atoms.
	--stupid-unmask, -sum        Remove incorrect unmasked atoms.
	--rm-comments, -c:           Delete lines starting with comment.
	--rm-all-comments, -ac:      Delete all comments.
	--full, -f:                  An analog '-s -t -uf -ku'
${contrast}Converting${restore}:
	--files-2-dirs, -f2d:        Converting package.* files to directories(comments will be removed).
	--dirs-2-files, -d2f:        Converting package.* dirs to files.
${contrast}Profile${restore}:
	--all-profiles-use, -apu:    List \${USE} defined in profiles.
	--profiles-use, -pu:         List \${USE} of profile.
	--current-profile-use, -cpu: \${USE} of current profile.
${contrast}world${restore}:
	--world-backup, -wb:         Create backup for current world file state.
	--world-restore, -wr:        Rolling up world file to one of available states.
	--world-regen, -wg:          Regen(cleanup) the world file.(backup: auto)
OPTIONS must be separated by SPACE."
}
############################################################################
################ run_it ####################################################
eix_dep_keys="--use-invalid
-ui
--use-make
-um
--use-full
-uf
--trash
-t
--force-trash
-ft
--full
-f"
opts=" ${PORTCONF_DEFAULT_OPTS} ${@}"
grep -q -e " \--yes\>" -e " \-y\>" <<< " ${opts}" && yes="1"
grep -q -e " \--pretend\>" -e " \-p\>" <<< " ${opts}" && pretend="1"
opts="$(sed -e 's| --yes\>||g;s| -y\>||g' -e 's| --pretend\>||g;s| -p\>||g' <<< " ${opts}")"
if grep -q "${eix_dep_keys//\-/\\-}" <<< "${opts}";then
	if grep -q -e " \--regen-cache\>" -e " \-rc\>" <<< " ${opts}";then
		eix_check
		opts="$(sed -e 's| --regen-cache\>||g;s| -rc\>||g' -e '/^[ \t]$/d' <<< " ${opts}")"
	else
		eix_method
	fi
else
	opts="$(sed -e 's| --regen-cache\>||g;s| -rc\>||g' -e '/^[ \t]$/d' <<< " ${opts}")"
fi
[[ -z "${@}" || -z "${opts}" ]] && help_pc
for opt in ${opts};do
	case "${opt}" in
	--backup | -b ) backup;;
	--restore | -r ) restore;;
	--sort | -s )
		backup;
		sort_use_file;
		uniq_keywords;
		sort_uniq_files;;
	--use-sort | -us )
		backup;
		sort_use_file;;
	--use-invalid | -ui )
		backup;
		invalid_uses;
		invalid_uses_make;
		[[ -n "${eix_cache}" ]] && rm "${eix_cache}";;
	--use-make | -um )
		backup;
		use_makeconf;;
	--use-full | -uf )
		backup;
		sort_use_file;
		invalid_uses;
		invalid_uses_make;
		use_makeconf;
		[[ -n "${eix_cache}" ]] && rm "${eix_cache}";;
	--keyword-one | -ko )
		backup;
		sort_keywords;;
	--keyword-uniq | -ku )
		backup;
		uniq_keywords;;
	--trash | -t )
		backup;
		not_found;
		env_not_installed;
		empty_files
		[[ -n "${eix_cache}" ]] && rm "${eix_cache}";;
	--stupid-mask | -sm )
		backup;
		mask_trash;;
	--stupid-unmask | -sum )
		backup;
		stupid_unmask;;
	--force-trash | -ft )
		backup;
		not_found;
		env_not_installed;
		force_not_installed;
		empty_files
		[[ -n "${eix_cache}" ]] && rm "${eix_cache}";;
	--rm-comments | -c )
		backup;
		rm_comments;;
	--rm-all-comments | -ac )
		backup;
		rm_all_comments;;
	--full | -f )
		backup;
		sort_uniq_files;
		not_found;
		env_not_installed;
		sort_use_file;
		invalid_uses;
		invalid_uses_make;
		use_makeconf;
		uniq_keywords;
		mask_trash;
		stupid_unmask;
		empty_files;
		[[ -n "${eix_cache}" ]] && rm "${eix_cache}";;
	--files-2-dirs | -f2d )
		backup;
		f_to_d;;
	--dirs-2-files | -d2f )
		backup;
		d_to_f;;
	--all-profiles-use | -apu ) all_use_all_profiles;;
	--profiles-use | -pu ) profile_use;;
	--current-profile-use | -cpu ) current_profile;;
	--world-backup | -wb ) world_backup;;
	--world-restore | -wr ) world_restore;;
	--world-regen | -wg )
		world_backup;
		regen_world;;
	--help | -h | -? | h ) help_pc;;
	esac
done
